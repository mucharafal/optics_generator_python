option, -echo, -info,  warn;

! defines a macro to read initial coordinates
getpart(nx): macro = {
 ex   = table(myevent,nx,trx);
 epx   = table(myevent,nx,trpx);
 ey   = table(myevent,nx,try);
 epy   = table(myevent,nx,trpy);
 et    = table(myevent,nx,tt);
 ept    = table(myevent,nx,tpt);
 value,ex,epx,ey,epy,et,ept;
}


set,format="4.12e";

call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/lhc_as-built.seq";
call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/opt_inj_colltunes.madx";

on_sep5=0;
px.ip5=185e-6;
!y.ip5=5.500000000000000e-04;
beta.ip5=0.400 ;

! Beam definition
beam, sequence=lhcb1, bv= 1, energy=6500,  particle=proton,
  npart=1.2e11,kbunch=2748, ex=7.29767146889e-09,ey=7.29767146889e-09;
beam, sequence=lhcb2, bv=-1, energy=6500,  particle=proton,
  npart=1.2e11,kbunch=2748, ex=7.29767146889e-09,ey=7.29767146889e-09;

use,sequence=lhcb1;

call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/temporary_perturbation.madx";
call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/perturbations_b1.madx";


! Matching part start

MQXA.1R5, K1 := ((LSA.MQXA.1R5)*(PERTSTRMQXA.1R5 + DMQXA.1R5)) * (1), polarity=1;

select, flag=error, clear;
select,flag=error, pattern=MQXA.1R5;
ealign, dpsi= PERTDPSIMQXA.1R5 + DPSIMQXA.1R5   ;
MCBXH.1R5, KICK := (LSA.MCBXH.1R5*(1.0 + DELTA_K_MCBXH.1R5)) * (1), polarity=1;
MCBXV.1R5, KICK := (LSA.MCBXV.1R5*(1.0 + 0)) * (1), polarity=1;
MQXB.A2R5, K1 := ((LSA.MQXB.A2R5)*(PERTSTRMQXB.A2R5 + DMQXB.A2R5)) * (1), polarity=-1;

select, flag=error, clear;
select,flag=error, pattern=MQXB.A2R5;
ealign, dpsi= PERTDPSIMQXB.A2R5 + DPSIMQXB.A2R5   ;
MCBXH.2R5, KICK := (LSA.MCBXH.2R5*(1.0 + DELTA_K_MCBXH.2R5)) * (1), polarity=1;
MCBXV.2R5, KICK := (LSA.MCBXV.2R5*(1.0 + 0)) * (1), polarity=1;
MQXB.B2R5, K1 := ((LSA.MQXB.B2R5)*(PERTSTRMQXB.B2R5 + DMQXB.B2R5)) * (1), polarity=-1;

select, flag=error, clear;
select,flag=error, pattern=MQXB.B2R5;
ealign, dpsi= PERTDPSIMQXB.B2R5 + DPSIMQXB.B2R5   ;
MQSX.3R5, K1S := (LSA.MQSX.3R5*(1.0 + 0)) * (1), polarity=1;
MQXA.3R5, K1 := ((LSA.MQXA.3R5)*(PERTSTRMQXA.3R5 + DMQXA.3R5)) * (1), polarity=1;

select, flag=error, clear;
select,flag=error, pattern=MQXA.3R5;
ealign, dpsi= PERTDPSIMQXA.3R5 + DPSIMQXA.3R5   ;
MCBXH.3R5, KICK := (LSA.MCBXH.3R5*(1.0 + DELTA_K_MCBXH.3R5)) * (1), polarity=1;
MCBXV.3R5, KICK := (LSA.MCBXV.3R5*(1.0 + 0)) * (1), polarity=1;
MCSX.3R5, KNL := {0, 0, (LSA.MCSX.3R5*(1.0 + 0)) * (1)*l.MCSX, 0, 0, 0}, polarity=1;
MCTX.3R5, KNL := {0, 0, 0, 0, 0, (LSA.MCTX.3R5*(1.0 + 0)) * (1)*l.MCTX}, polarity=1;
MCOSX.3R5, KSL := {0, 0, 0, (LSA.MCOSX.3R5*(1.0 + 0)) * (1)*l.MCOSX}, polarity=1;
MCOX.3R5, KNL := {0, 0, 0, (LSA.MCOX.3R5*(1.0 + 0)) * (1)*l.MCOX}, polarity=1;
MCSSX.3R5, KSL := {0, 0, (LSA.MCSSX.3R5*(1.0 + 0)) * (1)*l.MCSSX, 0}, polarity=1;
MBXW.A4R5, K0 := (((LSA.MBXW.A4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.A4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBXW.B4R5, K0 := (((LSA.MBXW.B4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.B4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBXW.C4R5, K0 := (((LSA.MBXW.C4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.C4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBXW.D4R5, K0 := (((LSA.MBXW.D4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.D4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBXW.E4R5, K0 := (((LSA.MBXW.E4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.E4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBXW.F4R5, K0 := (((LSA.MBXW.F4R5)*(1.0 + 0)) * (-1)) , ANGLE := ( ((LSA.MBXW.F4R5)*(1.0 + 0)) * (-1) * l.MBXW ), polarity=-1;
MBRC.4R5.B1, K0 := (((LSA.MBRC.4R5.B1)*(1.0 + 0)) * (1)) , ANGLE := ( ((LSA.MBRC.4R5.B1)*(1.0 + 0)) * (1) * l.MBRC ), polarity=1;
MCBYV.A4R5.B1, KICK := (LSA.MCBYV.A4R5.B1*(1.0 + 0)) * (1), polarity=1;
MCBYH.4R5.B1, KICK := (LSA.MCBYH.4R5.B1*(1.0 + 0)) * (1), polarity=1;
MCBYV.B4R5.B1, KICK := (LSA.MCBYV.B4R5.B1*(1.0 + 0)) * (1), polarity=1;
MQY.4R5.B1, K1 := ((LSA.MQY.4R5.B1)*(PERTSTRMQY.4R5.B1 + DMQY.4R5.B1)) * (1), polarity=-1;

select, flag=error, clear;
select,flag=error, pattern=MQY.4R5.B1;
ealign, dpsi= PERTDPSIMQY.4R5.B1 + DPSIMQY.4R5.B1   ;
MQML.5R5.B1, K1 := ((LSA.MQML.5R5.B1)*(PERTSTRMQML.5R5.B1 + DMQML.5R5.B1)) * (1), polarity=1;

select, flag=error, clear;
select,flag=error, pattern=MQML.5R5.B1;
ealign, dpsi= PERTDPSIMQML.5R5.B1 + DPSIMQML.5R5.B1   ;
MCBCH.5R5.B1, KICK := (LSA.MCBCH.5R5.B1*(1.0 + 0)) * (1), polarity=1;

! Matching part end


call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/LSA.str";

! Cycle
seqedit,sequence=lhcb1;flatten;cycle,start=IP5;endedit;

PI=3.141592654;
NORM_TRANS_EMITTANCE_M_RAD=3.5e-6;
PROTON_GAMMA=(6500/9.382720460000000e-01);


beg_150_station : marker;
seqedit,sequence=lhcb1;
install,element=beg_150_station,at=202.769,from=ip5;
endedit;



seqedit, sequence=lhcb1;flatten;cycle, start=IP5;endedit;

use,sequence=lhcb1;
!use,period=lhcb1,range=ip5/MQML.6R5.B1;
use,period=lhcb1,range=ip5/beg_150_station;


call,file="/home/stormtrooper/Ducttape/optics_generator_python/src/data/config/2016/temporary_perturbation_b1.madx";


readmytable,file=part.in,table=myevent;
    

ptc_create_universe; 
ptc_create_layout,model=2,method=6,nst=10,exact;
ptc_align;

! read in initial coordinates at set for tracking
   n=1;
   while ( n < 12000 + 1 ) {
      exec,getpart($n);
      ptc_start,x=ex,px=epx,y=ey,py=epy,t=et,pt=ept;
      n = n + 1;
   } !ok

!ptc_start,x=x.ip5,px=DELTA_PX_B1,y=y.ip5,py=py.ip5;

ptc_observe,place=beg_150_station;
ptc_observe,place=mqxb.b2r5;
ptc_observe,place=mcbxh.3r5;
ptc_observe,place=tanc.4r5;
ptc_observe,place=mcbxh.2r5;
ptc_observe,place=mqxa.3r5;
ptc_observe,place=mqml.5r5.b1;
ptc_observe,place=mcbch.5r5.b1;
ptc_observe,place=mcbyv.b4r5.b1;
 !ok

ptc_track,icase=5,element_by_element,dump,onetable,deltap=(DELTADELTAP + DDELTADELTAP_B1 + TOTEMDELTAP),file="track";

ptc_track_end;  
ptc_end;

return;
stop;

